import hook_vtflib
import os
import sys
import re
import subprocess
from ctypes import cast, POINTER, c_byte

# --- Determine the base path for bundled assets and modules ---
if getattr(sys, 'frozen', False):
    # When running as a Nuitka executable, the base path is the directory containing the .exe
    BASE_PATH = os.path.dirname(sys.executable)
    OUTPUT_ADDON_ROOT = BASE_PATH
else:
    # Running as a script
    BASE_PATH = os.path.dirname(os.path.abspath(__file__))
    OUTPUT_ADDON_ROOT = BASE_PATH

# --- Consolidate sys.path modification here ---
LIBS_PATH = os.path.join(BASE_PATH, 'libs')
if LIBS_PATH not in sys.path:
    sys.path.insert(0, LIBS_PATH)

# Add the script's base path (for VTFLibWrapper)
if BASE_PATH not in sys.path:
    sys.path.insert(1, BASE_PATH) # Insert at index 1 after LIBS_PATH

# --- Dependency Management ---
try:
    from PIL import Image, ImageSequence
except ImportError:
    print("ERROR: Pillow (PIL) is not found in the 'libs' folder or Python path.")
    print("Please ensure the 'libs' folder with Pillow is in the same directory as this script.")
    if sys.stdin and sys.stdin.isatty():
        input("\nPress Enter to exit.")
    sys.exit(1)

try:
    import VTFLibWrapper.VTFLib as VTFLib
    import VTFLibWrapper.VTFLibEnums as VTFLibEnums
except ImportError as e:
    print("ERROR: Could not import the VTFLib wrapper.")
    print("Please ensure the 'VTFLibWrapper' folder (containing VTFLib.py, etc.) is in the same directory as this script.")
    if sys.stdin and sys.stdin.isatty():
        input("\nPress Enter to exit.")
    sys.exit(1)

# --- Main Application Logic ---

# Compile regex patterns once at module level for better performance
_EMOJI_PATTERN = re.compile(
    "["
    "\U0001F600-\U0001F64F"  # emoticons
    "\U0001F300-\U0001F5FF"  # symbols & pictographs
    "\U0001F680-\U0001F6FF"  # transport & map symbols
    "\U0001F1E0-\U0001F1FF"  # flags (iOS)
    "\U00002700-\U000027BF"  # Dingbats
    "\U000024C2-\U0001F251" 
    "\U0001f926-\U0001f937"
    "\U00010000-\U0010ffff"
    "\u2640-\u2642"
    "\u2600-\u2B55"
    "\u200d"
    "\u23cf"
    "\u23e9"
    "\u231a"
    "\ufe0f"  # dingbats
    "\u3030"
    "]+", flags=re.UNICODE)

_FILENAME_SANITIZE_PATTERN = re.compile(r'[^a-zA-Z0-9]')

def remove_emojis(text):
    """Removes a wide range of emojis and symbols from a string."""
    if not text: return ""
    return _EMOJI_PATTERN.sub(r'', text)

def sanitize_for_filename(name):
    """Removes emojis, spaces, special characters, and converts to lowercase for filenames."""
    name_no_emoji = remove_emojis(name)
    return _FILENAME_SANITIZE_PATTERN.sub('', name_no_emoji).lower()

def letterbox_image(img, max_size=512):
    """
    Resizes and letterboxes an image to a square power-of-two canvas.
    Scales the image to have its largest dimension equal to max_size,
    preserving aspect ratio, to ensure stickers are large and not stretched.
    """
    w, h = img.width, img.height
    if w == 0 or h == 0:
        return None # Skip empty frames

    # 1. Calculate scaling factor to make the largest dimension match max_size
    max_dim = max(w, h)
    if max_dim == max_size:
        # Already the right size, just need to center on canvas
        new_w, new_h = w, h
        img_resized = img
    else:
        scale = max_size / max_dim
        new_w, new_h = int(w * scale), int(h * scale)
        # 2. Resize the image with the new dimensions
        # Using LANCZOS for high-quality resizing
        img_resized = img.resize((new_w, new_h), Image.LANCZOS)

    # 3. Create a transparent square canvas. Since max_size is a power of two,
    #    we can use it directly for the canvas size.
    canvas = Image.new("RGBA", (max_size, max_size), (0, 0, 0, 0))

    # 4. Paste the resized image onto the center of the canvas
    paste_x = (max_size - new_w) // 2
    paste_y = (max_size - new_h) // 2
    canvas.paste(img_resized, (paste_x, paste_y))

    return canvas

def create_addon_structure(output_path, pack_name):
    """Create the necessary directory structure for the ARC9 addon."""
    os.makedirs(os.path.join(output_path, f"arc9_{pack_name}_stickers", "lua", "arc9", "common", "attachments_bulk"), exist_ok=True)

def create_vmt(vmt_path, pack_name, subfolder, compact_name, is_animated, framerate):
    """Creates a .vmt file for either a static or animated sticker."""
    path_parts = ["stickers", pack_name, compact_name]
    material_path = "/".join(path_parts).replace("\\", "/")

    fingerprint = "// Generated by ARC9 Sticker Pack Maker++ by Midawek"

    if is_animated:
        vmt_content = f'''{fingerprint}
"VertexLitGeneric"
{{
    "$basetexture" "{material_path}"
    "$alphatest" "1"
    "$decal" "1"
    "$nocull" "1"
    "Proxies"
    {{
        "AnimatedTexture"
        {{
            "animatedTextureVar" "$basetexture"
            "animatedTextureFrameNumVar" "$frame"
            "animatedTextureFrameRate" "{framerate}"
        }}
    }}
}}'''
    else:
        vmt_content = f'''{fingerprint}
"VertexLitGeneric"
{{
    "$basetexture" "{material_path}"
    "$alphatest" "1"
    "$decal" "1"
    "$nocull" "1"
}}'''
    with open(vmt_path, "w", encoding="utf-8") as f:
        f.write(vmt_content)

def process_image_to_vtf(output_path, image_info, pack_name, compact_name, sticker_dir):
    """Processes a given image (static or animated) and creates VTF and VMT files."""
    subfolder = image_info.get("subfolder", "")
    
    vtf_path = os.path.join(sticker_dir, f"{compact_name}.vtf")
    vmt_path = os.path.join(sticker_dir, f"{compact_name}.vmt")
    
    vtf_lib = VTFLib.VTFLib()
    try:
        with Image.open(image_info["path"]) as img:
            is_animated = image_info["type"] == 'animated' and getattr(img, 'is_animated', False)

            options = vtf_lib.create_default_params_structure()
            options.ImageFormat = VTFLibEnums.ImageFormat.ImageFormatDXT5
            options.Flags |= VTFLibEnums.ImageFlag.ImageFlagEightBitAlpha
            options.Resize = False

            if is_animated:
                # --- CORRECT ANIMATED VTF CREATION USING THE WRAPPER ---
                frames = []
                durations = []
                # Convert to RGBA once for all frames if possible, otherwise convert per frame
                for frame in ImageSequence.Iterator(img):
                    # Only convert if not already RGBA
                    frame_rgba = frame if frame.mode == 'RGBA' else frame.convert("RGBA")
                    letterboxed_frame = letterbox_image(frame_rgba)
                    if letterboxed_frame:
                        frames.append(letterboxed_frame)
                        durations.append(frame.info.get('duration', 100))

                if not frames: raise Exception("Could not extract frames from animated image.")

                w, h = frames[0].size
                avg_duration_ms = sum(durations) / len(durations)
                framerate = round(1000 / avg_duration_ms) if avg_duration_ms > 0 else 15
                if framerate == 0: framerate = 15

                # 1. Create an empty multi-frame image with all required arguments
                if not vtf_lib.image_create(w, h, len(frames), 1, 1, options.ImageFormat, False, False, True):
                     raise Exception(f"image_create failed for animated VTF: {vtf_lib.get_last_error()}")

                # 2. Add each frame's data using the correct set_image_data method
                for i, frame in enumerate(frames):
                    frame_bytes = frame.tobytes()
                    frame_buffer_ptr = cast(frame_bytes, POINTER(c_byte))
                    # Use the correct method name: set_image_data
                    vtf_lib.set_image_data(i, 0, 0, 0, frame_buffer_ptr)

                create_vmt(vmt_path, pack_name, subfolder, compact_name, True, framerate)
            else:
                # --- Static Image Processing ---
                # Only convert if not already RGBA
                img_rgba = img if img.mode == 'RGBA' else img.convert("RGBA")
                texture = letterbox_image(img_rgba)
                w, h = texture.size
                image_bytes = texture.tobytes()
                image_buffer_ptr = cast(image_bytes, POINTER(c_byte))

                if not vtf_lib.image_create_single(w, h, image_buffer_ptr, options):
                    raise Exception(f"image_create_single failed: {vtf_lib.get_last_error()}")
                
                create_vmt(vmt_path, pack_name, subfolder, compact_name, False, 0)

            # 3. Save the final VTF file
            if not vtf_lib.image_save(vtf_path):
                raise Exception(f"image_save failed: {vtf_lib.get_last_error()}")
            
            return True

    except Exception as e:
        print(f"Error processing {image_info['original_name']}: {e}")
        return False
    finally:
        if vtf_lib:
            vtf_lib.shutdown()

def create_lua_script(output_path, pack_name, processed_images):
    """Create or append to the Lua script for the ARC9 addon from pre-processed info."""
    addon_root = os.path.join(output_path, f"arc9_{pack_name}_stickers")
    lua_path = os.path.join(addon_root, "lua", "arc9", "common", "attachments_bulk", f"a9sm_{pack_name}.lua")

    file_existed = os.path.exists(lua_path) and os.path.getsize(lua_path) > 0

    # Build Lua script content in memory for better performance
    lua_content_parts = []
    for i, info in enumerate(processed_images):
        print_name = remove_emojis(info["print_name"]).replace('"', '\\"')
        description = remove_emojis(info["description"]).replace(']]>', '] ]') # Avoid breaking multiline string
        subfolder = info.get("subfolder", "")

        # Add separator if this isn't the very first sticker in a new file
        if file_existed or i > 0:
            lua_content_parts.append("\n---\n\n")

        # Construct the folder path for the ATT table
        folder_value = pack_name
        if subfolder:
            folder_value = f"{pack_name}/{subfolder.replace('\\', '/')}"

        # Construct the material path for the sticker (without subfolder)
        sticker_material = f"stickers/{pack_name}/{info['compact_name']}"
        compact_name_upper = info["compact_name"].upper()

        lua_content_parts.append(f'''SPM = {{}}

SPM.PrintName = "{print_name}"
SPM.CompactName = "{compact_name_upper}"
SPM.Description = [[{description}]]

SPM.Icon = Material("{sticker_material}")

SPM.Free = true
SPM.Category = "stickers"
SPM.Folder = "{folder_value}"

SPM.StickerMaterial = "{sticker_material}"

ARC9.LoadAttachment(SPM, "sticker_{pack_name}_{info["compact_name"]}")''')

    # Write all content at once
    with open(lua_path, "a", encoding="utf-8") as f:
        f.write(''.join(lua_content_parts))

def main():
    """Main script execution flow."""
    logo = """
┏━ ┏━┓┏━┓┏━╸┏━┓ ━┓   ┏━┓╺┳╸╻┏━╸╻┏ ┏━╸┏━┓   ┏━┓┏━┓┏━╸╻┏    ┏┳┓┏━┓╻┏ ┏━╸┏━┓ ╻  ╻ 
┃  ┣━┫┣┳┛┃  ┗━┫  ┃   ┗━┓ ┃ ┃┃  ┣┻┓┣╸ ┣┳┛   ┣━┛┣━┫┃  ┣┻┓   ┃┃┃┣━┫┣┻┓┣╸ ┣┳┛╺╋╸╺╋╸
┗━ ╹ ╹╹┗╸┗━╸┗━┛ ━┛   ┗━┛ ╹ ╹┗━╸╹ ╹┗━╸╹┗╸   ╹  ╹ ╹┗━╸╹ ╹   ╹ ╹╹ ╹╹ ╹┗━╸╹┗╸ ╹  ╹ 
        ♡ by Midawek ♡ Made with love for ARC9 Community ♡
      """
    print(f"\033[95m{logo}\033[0m")
    
    # Determine the base directory for output
    if getattr(sys, 'frozen', False):
        output_path = os.path.dirname(sys.executable)
    else:
        output_path = os.path.dirname(os.path.abspath(__file__))

    image_folder_name = input("Enter the name of the folder with images: ")
    pack_name_input = input("Enter the name of the pack: ")
    pack_name = remove_emojis(pack_name_input)

    # Resolve image folder path relative to current working directory if not absolute
    if os.path.isabs(image_folder_name):
        image_folder_path = image_folder_name
    else:
        image_folder_path = os.path.join(os.getcwd(), image_folder_name)

    if not os.path.isdir(image_folder_path):
        print(f"Error: Folder '{image_folder_path}' not found.")
        input("\nPress Enter to exit.")
        return

    # 1. DISCOVERY PHASE: Try to open all files with Pillow
    images_to_process = []
    print("\nScanning for images...")
    for filename in sorted(os.listdir(image_folder_path)):
        file_path = os.path.join(image_folder_path, filename)
        if os.path.isdir(file_path): continue
        try:
            with Image.open(file_path) as img:
                original_name = os.path.splitext(filename)[0]
                is_animated = getattr(img, 'is_animated', False) and img.n_frames > 1
                images_to_process.append({
                    "path": file_path, 
                    "original_name": original_name, 
                    "type": "animated" if is_animated else "static"
                })
                print(f"Found {'animated' if is_animated else 'static'} image: {filename}")
        except (IOError, SyntaxError):
            continue # Skip files that are not images

    # 2. NAMING PHASE
    processed_info = []
    manual_naming = input("\nManually name each sticker and add a description? (y/n): ").lower().strip() == 'y'
    for item in images_to_process:
        default_print_name = item["original_name"].replace('_', ' ').title()
        print_name = default_print_name
        description = ""

        if manual_naming:
            print("\n----------------------------------------")
            print(f"Processing: {item['original_name']}")
            user_print_name = input(f"Enter display name (or press Enter for default: '{default_print_name}'): ")
            if user_print_name:
                print_name = user_print_name
            description = input("Enter description (optional): ")
        
        compact_name = sanitize_for_filename(print_name)
        item["print_name"] = print_name
        item["description"] = description
        item["compact_name"] = compact_name
        processed_info.append(item)

    # 3. CREATION PHASE
    create_addon_structure(output_path, pack_name)
    
    # Create sticker directory once (shared by all images)
    addon_root = os.path.join(output_path, f"arc9_{pack_name}_stickers")
    sticker_dir = os.path.join(addon_root, "materials", "stickers", pack_name)
    os.makedirs(sticker_dir, exist_ok=True)
    
    successful_images = []
    print("\nStarting image conversion...")
    total_images = len(processed_info)
    for i, info in enumerate(processed_info):
        print(f"({i+1}/{total_images}) Processing '''{info['original_name']}''' -> '''{info['compact_name']}.vtf'''...")
        if process_image_to_vtf(output_path, info, pack_name, info["compact_name"], sticker_dir):
            successful_images.append(info)

    # 4. FINALIZATION PHASE
    if successful_images:
        print("\nConversion complete. Now generating Lua script...")
        create_lua_script(output_path, pack_name, successful_images)
        print(f"\nSuccessfully created the '{pack_name}' sticker pack!")
    else:
        print("\nNo images were successfully converted. Addon creation aborted.")

    input("\nPress Enter to exit.")

if __name__ == "__main__":
    main()
